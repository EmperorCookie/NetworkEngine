<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// PROPERTIES //
timeout = 1;
tick_rate = 20;
port = 6942;
max_players = 16;
// LOGIC //
local_entities = ds_list_create();
connections = ds_map_create();
zone_map = ds_map_create();
zone_list = ds_list_create();
tick = 0;
socket = -1;
socket_udp = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_list_destroy(local_entities);
ds_map_destroy(connections);
ds_map_destroy(zone_map);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// CONNECTION TIMEOUT //
var delta = delta_time * 0.000001;
with(server_connection) {
    timeout += delta;
    // TODO - PING //
    // TODO - DISCONNECT //
}
// NETWORK UPDATE //
tick += tick_rate * delta;
if(tick &gt;= 1) {
    tick = frac(tick);
    // SEND UPDATE TO EVERYONE //
    var tcp_sync = buffer_create(1, buffer_grow, 1);
    var udp_sync = buffer_create(1, buffer_grow, 1);
    buffer_write(tcp_sync, buffer_u8, NET.SYNC_ENTITY);
    buffer_write(udp_sync, buffer_u8, NET.SYNC_ENTITY);
    var tcp_updates = false;
    var udp_updates = false;
    for(var a = ds_list_size(local_entities) - 1; a &gt;= 0; a -= 1) {
        with(local_entities[|a]) {
            var tcp_done = false;
            var udp_done = false;
            if(sync_properties) {
                buffer_write(udp_sync, buffer_bool, true);
                buffer_write(udp_sync, buffer_u32, server_id);
                udp_done = true;
                udp_updates = true;
                buffer_write(udp_sync, buffer_bool, true);
                buffer_write(udp_sync, buffer_u8, SYNC.PROPERTIES);
                buffer_write(udp_sync, buffer_bool, solid);
                buffer_write(udp_sync, buffer_bool, visible);
                buffer_write(udp_sync, buffer_bool, persistent);
                buffer_write(udp_sync, buffer_f64, depth);
                buffer_write(udp_sync, buffer_u32, sprite_index);
                buffer_write(udp_sync, buffer_f64, image_alpha);
                buffer_write(udp_sync, buffer_f64, image_blend);
                buffer_write(udp_sync, buffer_f64, image_index);
                buffer_write(udp_sync, buffer_f64, image_speed);
                buffer_write(udp_sync, buffer_f64, image_single);
                buffer_write(udp_sync, buffer_f64, image_xscale);
                buffer_write(udp_sync, buffer_f64, image_yscale);
            }
            if(sync_movement) {
                if(!udp_done) {
                    buffer_write(udp_sync, buffer_bool, true);
                    buffer_write(udp_sync, buffer_u32, server_id);
                    udp_done = true;
                    udp_updates = true;
                }
                buffer_write(udp_sync, buffer_bool, true);
                buffer_write(udp_sync, buffer_u8, SYNC.MOVEMENT);
                buffer_write(udp_sync, buffer_f64, friction);
                buffer_write(udp_sync, buffer_f64, gravity);
                buffer_write(udp_sync, buffer_f64, gravity_direction);
                buffer_write(udp_sync, buffer_f64, hspeed);
                buffer_write(udp_sync, buffer_f64, vspeed);
                buffer_write(udp_sync, buffer_f64, x);
                buffer_write(udp_sync, buffer_f64, y);
            }
            if(sync_physics) {
                if(!phy_sleeping) {
                    if(!udp_done) {
                        buffer_write(udp_sync, buffer_bool, true);
                        buffer_write(udp_sync, buffer_u32, server_id);
                        udp_done = true;
                        udp_updates = true;
                    }
                    buffer_write(udp_sync, buffer_bool, true);
                    buffer_write(udp_sync, buffer_u8, SYNC.PHYSICS);
                    buffer_write(udp_sync, buffer_bool, phy_active);
                    buffer_write(udp_sync, buffer_f64, phy_angular_velocity);
                    buffer_write(udp_sync, buffer_f64, phy_angular_damping);
                    buffer_write(udp_sync, buffer_f64, phy_linear_velocity_x);
                    buffer_write(udp_sync, buffer_f64, phy_linear_velocity_y);
                    buffer_write(udp_sync, buffer_f64, phy_linear_damping);
                    buffer_write(udp_sync, buffer_f64, phy_speed_x);
                    buffer_write(udp_sync, buffer_f64, phy_speed_y);
                    buffer_write(udp_sync, buffer_f64, phy_position_x);
                    buffer_write(udp_sync, buffer_f64, phy_position_y);
                    buffer_write(udp_sync, buffer_f64, phy_rotation);
                    buffer_write(udp_sync, buffer_f64, phy_fixed_rotation);
                    buffer_write(udp_sync, buffer_bool, phy_bullet);
                }
            }
            var tcp_var_done = false;
            var udp_var_done = false;
            for(var i = ds_list_size(sv_names) - 1; i &gt;= 0; i -= 1) {
                var n = sv_names[|i];
                if(sv_tcp[?n]) {
                    if(sv_changed[?n]) {
                        sv_changed[?n] = false;
                        if(!tcp_done) {
                            buffer_write(tcp_sync, buffer_bool, true);
                            buffer_write(tcp_sync, buffer_u32, server_id);
                            tcp_done = true;
                            tcp_updates = true;
                        }
                        if(!tcp_var_done) {
                            buffer_write(tcp_sync, buffer_bool, true);
                            buffer_write(tcp_sync, buffer_u8, SYNC.VARIABLES);
                            tcp_var_done = true;
                        }
                        buffer_write(tcp_sync, buffer_bool, true);
                        buffer_write(tcp_sync, buffer_string, n);
                        buffer_write(tcp_sync, buffer_u8, sv_types[?n]);
                        buffer_write(tcp_sync, sv_types[?n], sv_values[?n]);
                    }
                } else {
                    if(!udp_done) {
                        buffer_write(udp_sync, buffer_bool, true);
                        buffer_write(udp_sync, buffer_u32, server_id);
                        udp_done = true;
                        udp_updates = true;
                    }
                    if(!udp_var_done) {
                        buffer_write(udp_sync, buffer_bool, true);
                        buffer_write(udp_sync, buffer_u8, SYNC.VARIABLES);
                        udp_var_done = true;
                    }
                    buffer_write(udp_sync, buffer_bool, true);
                    buffer_write(udp_sync, buffer_string, n);
                    buffer_write(udp_sync, buffer_u8, sv_types[?n]);
                    buffer_write(udp_sync, sv_types[?n], sv_values[?n]);
                }
            }
            if(tcp_var_done) {
                buffer_write(tcp_sync, buffer_bool, false);
            }
            if(udp_var_done) {
                buffer_write(udp_sync, buffer_bool, false);
            }
            if(tcp_done) {
                buffer_write(tcp_sync, buffer_bool, false);
            }
            if(udp_done) {
                buffer_write(udp_sync, buffer_bool, false);
            }
        }
    }
    if(tcp_updates) {
        buffer_write(tcp_sync, buffer_bool, false);
        with(server_connection) {
            network_send_packet(socket, tcp_sync, buffer_tell(tcp_sync));
        }
    }
    buffer_delete(tcp_sync);
    if(udp_updates) {
        buffer_write(udp_sync, buffer_bool, false);
        with(server_connection) {
            if(port_udp != -1) {
                network_send_udp(other.socket_udp, ip, port_udp, udp_sync, buffer_tell(udp_sync));
            }
        }
    }
    buffer_delete(udp_sync);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var sock;
sock = async_load[?"id"];
// DISCARD PACKET THAT IS NOT OWNED BY THE SERVER //
if(sock != socket &amp;&amp; sock != socket_udp &amp;&amp; !ds_map_exists(connections, sock)) {
    exit;
}
// ANALYSE PACKET //
var type;
type = async_load[?"type"];
// DATA PACKET //
if(type == network_type_data) {
    server_packet_handle(async_load[?"buffer"], sock);
// CONNECTION PACKET //
} else {
    var newsocket, i;
    newsocket = async_load[?"socket"];
    // DISCONNECTION //
    if(type == network_type_disconnect) {
        i = connections[?newsocket];
        var total_instances = ds_list_size(i.entities);
        if(total_instances &gt; 0) {
            var buff = buffer_create(1, buffer_grow, 1);
            buffer_write(buff, buffer_u8, NET.DESTROY);
            for(var a = 0; a &lt; total_instances; a += 1) {
                var e = i.entities[|a];
                buffer_write(buff, buffer_u32, e);
                buffer_write(buff, buffer_bool, (a &lt; total_instances - 1));
                with(e) {
                    entity_cleanup();
                }
            }
        }
        with(i) {
            instance_destroy();
        }
        ds_map_delete(connections, newsocket);
        if(total_instances &gt; 0) {
            with(server_connection) {
                network_send_packet(socket, buff, buffer_tell(buff));
            }
            buffer_delete(buff);
        }
    // CONNECTION //
    } else {
        if(ds_map_exists(connections, newsocket)) {
            i = connections[?newsocket];
            with(i) {
                instance_destroy();
            }
        }
        i = instance_create(0, 0, server_connection);
        connections[?newsocket] = i;
        i.timeout = 0;
        i.ip = async_load[?"ip"];
        i.socket = newsocket;
        // SEND TICK RATE //
        var buff = buffer_create(1, buffer_grow, 1);
        buffer_write(buff, buffer_u8, NET.TICK_RATE);
        buffer_write(buff, buffer_u8, tick_rate);
        network_send_packet(newsocket, buff, buffer_tell(buff));
        buffer_delete(buff);
        // SEND ALL EXISTING ENTITIES AND THEIR TCP SYNC VARIABLES //
        var total_instances = 0;
        // CREATE BUFFER //
        buff = buffer_create(1, buffer_grow, 1);
        buffer_write(buff, buffer_u8, NET.CREATE);
        for(var a = ds_list_size(local_entities) - 1; a &gt;= 0; a -= 1) {
            total_instances += 1;
            buffer_write(buff, buffer_bool, 1);
            var e = local_entities[|a];
            buffer_write(buff, buffer_f64, e.x);
            buffer_write(buff, buffer_f64, e.y);
            buffer_write(buff, buffer_u32, e.object_index);
            buffer_write(buff, buffer_u32, e);
            // MARK SYNC VARIABLES AS CHANGED TO FORCE SYNC //
            with(e) {
                for(var b = ds_list_size(sv_names) - 1; b &gt;= 0; b -= 1) {
                    sv_changed[?sv_names[|b]] = true;
                }
            }
        }
        // SYNC REQUEST BUFFER //
        var sync = buffer_create(1, buffer_grow, 1);
        buffer_write(sync, buffer_u8, NET.SYNC_REQUEST);
        with(server_connection) {
            if(id != i) {
                for(var a = ds_list_size(entities) - 1; a &gt;= 0; a -= 1) {
                    total_instances += 1;
                    buffer_write(buff, buffer_bool, 1);
                    var e = entities[|a];
                    buffer_write(buff, buffer_f64, e.x);
                    buffer_write(buff, buffer_f64, e.y);
                    buffer_write(buff, buffer_u32, e.object_index);
                    buffer_write(buff, buffer_u32, e);
                }
                network_send_packet(socket, sync, buffer_tell(buff));
            }
        }
        if(total_instances &gt; 0) {
            buffer_write(buff, buffer_bool, 0);
            network_send_packet(newsocket, buff, buffer_tell(buff));
        }
        buffer_delete(buff);
        buffer_delete(sync);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>server_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
